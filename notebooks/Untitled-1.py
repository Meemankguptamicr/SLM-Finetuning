import PyPDF2

# Open the original PDF
with open(r"C:\Users\meemankgupta\Downloads\健診DM1（告知＝健診）.pdf", "rb") as input_file:
    reader = PyPDF2.PdfReader(input_file)
    writer = PyPDF2.PdfWriter()

    # Iterate through all the pages
    for page_num in range(len(reader.pages)):
        page = reader.pages[page_num]
        
        # Get the original rotation angle (default to 0 if not set)
        rotation = page.get('/Rotate', 0)
        print(f"Page {page_num + 1} Original Rotation: {rotation} degrees")

        # Adjust the rotation to 0 degrees if needed
        if rotation in [90, 180, 270]:
            page.rotate(-rotation)

        # Add the rotated page to the writer
        writer.add_page(page)

    # Save the result document with all pages corrected
    with open(r"C:\Users\meemankgupta\Downloads\RotatePage_All.pdf", "wb") as output_file:
        writer.write(output_file)

print("PDF rotation completed for all pages.")
# import libraries# import librariesimport osimport timefrom azure.ai.formrecognizer import DocumentAnalysisClientfrom azure.core.credentials import AzureKeyCredentialfrom PyPDF2 import PdfReader, PdfWriterfrom reportlab.pdfgen import canvasfrom reportlab.lib.pagesizes import letterfrom reportlab.pdfbase import pdfmetricsfrom reportlab.pdfbase.ttfonts import TTFontfrom reportlab.lib.pagesizes import A4from reportlab.lib.units import inchimport requestsimport jsonimport mathdef euclidean_distance(point1, point2):    return math.sqrt(        math.pow(point2[0] - point1[0], 2) + math.pow(point2[1] - point1[1], 2)    )def create_formatted_pdf_with_text(    box_texts, page_width, page_height, rotation_angle, filename):    page_dim = max(page_width, page_height)    c = canvas.Canvas(filename, pagesize=(page_dim * inch, page_dim * inch))    # Register a default font    pdfmetrics.registerFont(TTFont("Vera", "Vera.ttf"))    font_size = 10    for item in box_texts:        # Calculate the width and height of the box        text = item["content"]        box_coordinates = [i * 72 for i in item["polygon"]]        start_x = box_coordinates[6]        start_y = page_height * 72 - box_coordinates[7]        dim1 = euclidean_distance(            (box_coordinates[0], box_coordinates[1]),            (box_coordinates[2], box_coordinates[3]),        )        dim2 = euclidean_distance(            (box_coordinates[0], box_coordinates[1]),            (box_coordinates[6], box_coordinates[7]),        )        if dim1 == dim2:            width = height = dim1        else:            width = max(dim1, dim2)            height = min(dim1, dim2)        # Calculate the width of the string in points        string_width = pdfmetrics.stringWidth(text, "Vera", font_size)        # Adjust the font size until the width of the string is less than the width of the rectangle        while string_width > width or font_size > height:            font_size -= 0.5            string_width = pdfmetrics.stringWidth(text, "Vera", font_size)        while string_width < width and font_size < height:            font_size += 0.5            string_width = pdfmetrics.stringWidth(text, "Vera", font_size)        if string_width > width or font_size > height:            font_size -= 0.5        # Set the font size        c.setFont("Vera", font_size)        c.saveState()        c.translate(start_x, start_y)        c.rotate(-rotation_angle)        c.drawString(0, 0, text)        c.restoreState()    c.save()    return cendpoint = os.environ.get("DOCUMENT_INTELLIGENCE_ENDPOINT")key = os.environ.get("DOCUMENT_INTELLIGENCE_KEY")your_document_url = "Your doc url"modelId = "prebuilt-layout"api_version = "2023-07-31"url = f"{endpoint}/formrecognizer/documentModels/{modelId}:analyze?api-version={api_version}"headers = {    "Content-Type": "application/json",    "Ocp-Apim-Subscription-Key": key,}data = {    "urlSource": your_document_url,}response = requests.post(url, headers=headers, data=json.dumps(data))if response.status_code != 202:    print(response.json())    quit()# get Operation-Location from response headerresult_url = response.headers["Operation-Location"]time.sleep(2)response_text = {"status": "notStarted"}while response_text["status"] in ["running", "notStarted"]:    response = requests.get(result_url, headers=headers)    response_text = json.loads(response.text)    time.sleep(1)analysis_result = response_text["analyzeResult"]content = analysis_result["content"]pages = analysis_result["pages"]tables = analysis_result["tables"]paragraphs = analysis_result["paragraphs"]styles = analysis_result["styles"]page_wise_lines = []for page_index, page in enumerate(pages):    page_number = page_index + 1    page_values = {        "page_number": page_number,        "angle": page["angle"],        "width": page["width"],        "height": page["height"],        "unit": page["unit"],        "lines": [],    }    for line in page["lines"]:        page_values["lines"].append(            {"polygon": line["polygon"], "content": line["content"]}        )    page_wise_lines.append(page_values)pdf_writer = PdfWriter()for page_content in page_wise_lines:    text_lines = page_content["lines"]    rotation_angle = page_content["angle"]    page_width, page_height = page_content["width"], page_content["height"]    # page_dim = max(page_width, page_height)    filename = f"page_{page_content['page_number']}.pdf"    canvas_copy = create_formatted_pdf_with_text(        text_lines, page_width, page_height, rotation_angle, filename    )    pdf_reader = PdfReader(filename)    os.remove(filename)    pdf_page = pdf_reader.pages[0]    # rotate page    if rotation_angle < 0:        adjustable_angle = abs(rotation_angle)    else:        adjustable_angle = 360 - rotation_angle    quadrant, quadrant_deviation = int(adjustable_angle / 90), adjustable_angle % 90    if quadrant_deviation > 45:        quadrant += 1    angle_modification = quadrant * 90    pdf_page.rotate(angle_modification)    # add new page    pdf_writer.add_page(pdf_page)with open("rotated_pages.pdf", "wb") as fh:    pdf_writer.write(fh) 